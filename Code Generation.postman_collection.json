{
	"info": {
		"_postman_id": "fb7572f6-2f76-4621-b40f-ace21ca29b55",
		"name": "Code Generation",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "973834"
	},
	"item": [
		{
			"name": "Meta Documentation",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"",
							"const currentRaw = JSON.parse(pm.environment.get('documentation_current'));",
							"const currentEntity = pm.environment.get('documentation_entity');",
							"const currentEntityMission = pm.environment.get('documentation_entity_mission');",
							"const currentParts = currentRaw.match(/^\\# (?:[A-z0-9 ]+ - )?(?:[A-z0-9]+)+\\n+((?:.|\\n)*)\\n+(<table>(?:.|\\n)*?<\\/table>|(?:\\n\\|.*\\|)+)((.|\\n)*)/);",
							"const currentFields = {};",
							"",
							"const currentDescription = currentParts ? currentParts[1] : '';",
							"const currentExtraInfo = currentParts ? currentParts[3] : '';",
							"const currentRawTable = currentParts ? currentParts[2].trim() : '';",
							"if (/<table>/.test(currentRawTable)) {",
							"    const $ = require('cheerio').load(currentRawTable);",
							"",
							"    $('tr').each((index, row) => {",
							"        row = $(row);",
							"        if(row.attr('class') === 'header') {",
							"            return;",
							"        }",
							"        const columns = $('td', row);",
							"        currentFields[$(columns[0]).html()] = {",
							"            type: $(columns[1]).html(),",
							"            description: $(columns[2]).html(),",
							"            optional: $(columns[3]).html().toLowerCase() !== 'x',",
							"            readOnly: $(columns[4]).html().toLowerCase() === 'x',",
							"        };",
							"    });",
							"} else {",
							"    const rows = currentRawTable.split('\\n');",
							"    rows.forEach((row, index) => {",
							"        if (index < 2) {",
							"            return; //Ignore headers",
							"        }",
							"        row = row.trim();",
							"        const columns = row.substring(1, row.length - 1).split('|').map(column => column.trim());",
							"        while(columns.length < 5) {",
							"            columns.push('');",
							"        }",
							"        currentFields[columns[0]] = {",
							"            type: columns[1],",
							"            description: columns[2],",
							"            optional: columns[3].toLowerCase() !== 'x',",
							"            readOnly: columns[4].toLowerCase() === 'x',",
							"        };",
							"    })",
							"}",
							"",
							"let jsonData = JSON.parse(pm.response.text());",
							"let customCounts = {",
							"    customText: 1,",
							"    customTextBlock: 1,",
							"    customDate: 1,",
							"    customFloat: 1,",
							"    customInt: 1,",
							"};",
							"let fields = jsonData.fields",
							".sort((fieldA, fieldB) => {",
							"    if (fieldA.name === 'id') {",
							"        return -1;",
							"    }",
							"    if (fieldB.name === 'id') {",
							"        return 1;",
							"    }",
							"    return fieldA.name < fieldB.name ? -1 : 1;",
							"})",
							".filter((field) => {",
							"    if (field.name !== 'customText1' && /^customText[0-9]+/.test(field.name)) {",
							"        customCounts.customText++;",
							"        return false;",
							"    }",
							"    if (field.name !== 'customTextBlock1' && /^customTextBlock[0-9]+/.test(field.name)) {",
							"        customCounts.customTextBlock++;",
							"        return false;",
							"    }",
							"    if (field.name !== 'customDate1' && /^customDate[0-9]+/.test(field.name)) {",
							"        customCounts.customDate++;",
							"        return false;",
							"    }",
							"    if (field.name !== 'customFloat1' && /^customFloat[0-9]+/.test(field.name)) {",
							"        customCounts.customFloat++;",
							"        return false;",
							"    }",
							"    if (field.name !== 'customInt1' && /^customInt/.test(field.name)) {",
							"        customCounts.customInt++;",
							"        return false;",
							"    }",
							"    return true;",
							"})",
							".map((field) => {",
							"    switch(field.type) {",
							"        case 'TO_ONE':",
							"            field.type = `To-one association`",
							"            break;",
							"        case 'TO_MANY':",
							"            field.type = `To-many association`",
							"            break;",
							"    }",
							"    let description = field.optionsType || '';",
							"    switch(field.name) {",
							"        case 'id':",
							"            description = 'Unique identifier for this entity.';",
							"            break;",
							"        case 'customText1':",
							"            field.name = `customText1-${customCounts.customText}`;",
							"            description = 'Configurable text fields that can be used to store custom data depending on the needs of a particular deployment.';",
							"            break;",
							"        case 'customTextBlock1':",
							"            field.name = `customTextBlock1-${customCounts.customTextBlock}`;",
							"            description = 'Configurable text fields that can be used to store custom data depending on the needs of a particular deployment.';",
							"            break;",
							"        case 'customDate1':",
							"            field.name = `customDate1-${customCounts.customDate}`;",
							"            description = 'Configurable date fields that can be used to store custom data depending on the needs of a particular deployment.';",
							"            break;",
							"        case 'customFloat1':",
							"            field.name = `customFloat1-${customCounts.customFloat}`;",
							"            description = 'Configurable numeric fields that can be used to store custom data depending on the needs of a particular deployment.';",
							"            break;",
							"        case 'customInt1':",
							"            field.name = `customInt1-${customCounts.customInt}`;",
							"            description = 'Configurable numeric fields that can be used to store custom data depending on the needs of a particular deployment.';",
							"            break;",
							"    }",
							"    if (field.type === 'SCALAR') {",
							"        field.type = field.dataType;",
							"    }",
							"    if (field.type === 'String') {",
							"        field.type += ` (${field.maxLength})`;",
							"    }",
							"    if (field.name === 'id') {",
							"        field.type = 'Integer';",
							"        field.optional = false;",
							"        field.readOnly = true;",
							"    }",
							"    if (currentFields[field.name]) {",
							"        const currentField = currentFields[field.name];",
							"        field.optional = currentField.optional;",
							"        description = currentField.description;",
							"        field.readOnly = currentField.readOnly;",
							"    }",
							"    return {",
							"        name: field.name,",
							"        type: field.type,",
							"        description: description,",
							"        notNull: !field.optional,",
							"        readOnly: field.readOnly,",
							"    };",
							"});",
							"",
							"let fieldOutput = fields.map((field, index) => {",
							"    return `        <tr class=\"${index % 2 === 0 ? 'even' : 'odd'}\">",
							"            <td>${field.name}</td>",
							"            <td>${field.type}</td>",
							"            <td>${field.description}</td>",
							"            <td>${field.notNull?'X':''}</td>",
							"            <td>${field.readOnly?'X':''}</td>",
							"        </tr>`;",
							"}).join(\"\\n\");",
							"let output = `# ${currentEntityMission.length > 0 ? currentEntityMission + ' - ' : ''}${currentEntity}",
							"",
							"${currentDescription}",
							"<table>",
							"    <colgroup>",
							"        <col width=\"20%\" />",
							"        <col width=\"20%\" />",
							"        <col width=\"20%\" />",
							"        <col width=\"20%\" />",
							"        <col width=\"20%\" />",
							"    </colgroup>",
							"    <thead>",
							"        <tr class=\"header\">",
							"            <th>${jsonData.entity} fields</th>",
							"            <th>Type</th>",
							"            <th>Description</th>",
							"            <th>Not null</th>",
							"            <th>Read-only</th>",
							"        </tr>",
							"    </thead>",
							"    <tbody>",
							"${fieldOutput}",
							"    </tbody>",
							"</table>${currentExtraInfo}`;",
							"pm.test(`${jsonData.entity} to view: View -> Show Postman Console`, () => {",
							"    console.log(output);",
							"    pm.expect(true).to.eql(true);",
							"});"
						],
						"type": "text/javascript",
						"packages": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"//If it is a new entity, fill in originalEntity and optionally originalEntityMission",
							"//If it is an existing entity, copy and paste the current documentation",
							"const originalEntity = '';",
							"const originalEntityMission = '';",
							"const currentDocumentation = ``;",
							"",
							"if (currentDocumentation && originalEntity) {",
							"    throw new Error('You must fill out either the original or the originalEntity');",
							"}",
							"",
							"pm.environment.set('documentation_current', JSON.stringify(currentDocumentation));",
							"const documentation_entity_matches = currentDocumentation.match(/^\\# (?:([A-z0-9 ]+) - )?([A-z0-9]+)/);",
							"pm.environment.set('documentation_entity_mission', originalEntityMission || documentation_entity_matches[1]);",
							"pm.environment.set('documentation_entity', originalEntity || documentation_entity_matches[2]);"
						],
						"type": "text/javascript",
						"packages": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{restUrl}}meta/{{documentation_entity}}?fields=*&meta=full",
					"host": [
						"{{restUrl}}meta"
					],
					"path": [
						"{{documentation_entity}}"
					],
					"query": [
						{
							"key": "fields",
							"value": "*"
						},
						{
							"key": "meta",
							"value": "full"
						}
					]
				}
			},
			"response": []
		}
	]
}